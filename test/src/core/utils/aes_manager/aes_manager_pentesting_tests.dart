import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:fuzzy_chat/src/core/core.dart';
import 'package:pointycastle/api.dart';
import 'package:test/test.dart';
import 'aes_manager_test_hooks.dart';

void main() {
  group('AESManager – Advanced Misuse & Integrity', () {
    late Uint8List goodKey;
    setUp(() async => goodKey = await AESService.generateKey());

    test('generateKey passes χ² sanity check', () async {
      // ── Collect ≥16 KiB of random data (512 keys × 32 bytes) ──
      final sampleBytes = Uint8List(32 * 512);
      for (var i = 0; i < 512; ++i) {
        final key = await AESService.generateKey(); // 32-byte key
        sampleBytes.setRange(i * 32, (i + 1) * 32, key);
      }

      // ── Compute Pearson χ² over the 256 byte-value buckets ──
      final counts = List<int>.filled(256, 0);
      for (final b in sampleBytes) {
        counts[b]++;
      }

      final expected = sampleBytes.length / 256; // ≈64 per bucket
      double chi2 = 0;
      for (final c in counts) {
        chi2 += pow(c - expected, 2) / expected;
      }

      // 5-to-95 % region for df=255 is ~180–330
      expect(
        chi2,
        inInclusiveRange(180, 330),
        reason: 'χ²=$chi2 suggests obvious bias in generateKey RNG',
      );
    });

    for (final location in ['body', 'tag']) {
      test('tampering one byte of $location triggers auth failure ($location)', () async {
        final pt = fixtureBytes(256 + Random().nextInt(1024));
        final ct = await AESService.encrypt(pt, goodKey);

        // Flip one random bit in either data or tag
        final idx =
            location == 'body' ? _saltNonceLen + Random().nextInt(ct.length - _saltNonceLen - 1) : ct.length - 1;
        ct[idx] ^= 0x08;

        expect(
          () async => await AESService.decrypt(ct, goodKey),
          throwsA(isA<InvalidCipherTextException>()),
        );
      });
    }

    test('re-encrypting with same nonce+salt generates identical output – flag misuse', () async {
      final pt = fixtureBytes(128);
      final manualNonce = Uint8List.fromList(List<int>.generate(12, (_) => 0)); // zero-nonce
      final manualSalt = Uint8List.fromList(List<int>.generate(24, (_) => 1)); // zero-salt

      final ct1 = AESManagerTestHooks.encryptWithFixedSaltNonce(
        pt,
        goodKey,
        manualSalt,
        manualNonce,
      );
      final ct2 = AESManagerTestHooks.encryptWithFixedSaltNonce(
        pt,
        goodKey,
        manualSalt,
        manualNonce,
      );

      expect(ct1, equals(ct2), reason: 'Identical ciphertext shows nonce reuse ⇒ highlight audit item');
    });

    test('HKDF derivation uniqueness', () {
      final saltA = fixtureBytes(24);
      final saltB = fixtureBytes(24);

      final k1 = AESManagerTestHooks.deriveEphemeral(mainKey: goodKey, salt: saltA);
      final k2 = AESManagerTestHooks.deriveEphemeral(mainKey: goodKey, salt: saltA);
      final k3 = AESManagerTestHooks.deriveEphemeral(mainKey: goodKey, salt: saltB);

      expect(k1, equals(k2));
      expect(k1, isNot(equals(k3)));
      expect(k1.length, 32);
    });

    test('encrypt/decrypt zero-byte input', () async {
      final pt = Uint8List(0);
      final ct = await AESService.encrypt(pt, goodKey);
      final dec = await AESService.decrypt(ct, goodKey);
      expect(dec, pt);
    });

    test(
      'large stream encrypt/decrypt (32 MiB)',
      () async {
        final pt = fixtureBytes(32 * 1024 * 224);
        final ct = await AESService.encrypt(pt, goodKey);
        final dec = await AESService.decrypt(ct, goodKey);
        expect(dec, pt);
      },
      timeout: const Timeout(
        Duration(minutes: 3),
      ),
    );

    //TODO add when cancel functinality is fully supported
    // test('file encrypt cancel -> output deleted', () async {
    //   final inp = await fixtureFile(size: 1 * 1024 * 1024); // 1 MiB
    //   final out = '${inp.path}.enc';
    //   final handler = await AESManager.encryptFile(
    //     inputPath: inp.path,
    //     outputPath: out,
    //     key: goodKey,
    //   );

    //   var lastProgress = 0.0;
    //   late StreamSubscription<dynamic> sub;
    //   sub = handler.progressStream.listen((p) {
    //     expect(p.progress, inInclusiveRange(lastProgress, 1.0));
    //     lastProgress = p.progress;
    //   });

    //   await sub.asFuture<void>();
    //   await sub.cancel();

    //   expect(await File(out).exists(), isFalse, reason: 'Cancel should delete partial output');
    // });

    test(
      'stress isolates (16 × 100)',
      () async {
        await Future.wait(
          List<Future<dynamic>>.generate(16, (i) async {
            for (var j = 0; j < 100; ++j) {
              final pt = fixtureBytes(64 + (i + j) % 64);
              final ct = await AESService.encrypt(pt, goodKey);
              final dec = await AESService.decrypt(ct, goodKey);
              expect(dec, pt);
            }
          }),
        );
      },
      timeout: const Timeout(
        Duration(minutes: 2),
      ),
    );
  });
}

const _saltNonceLen = 24 + 12;

final _rng = Random.secure();

Uint8List fixtureBytes(int length) => Uint8List.fromList(List<int>.generate(length, (_) => _rng.nextInt(256)));

/// Creates a temporary file filled with [size] random bytes.
/// The caller is responsible for deleting the file (or its parent directory)
/// when finished.
Future<File> fixtureFile({required int size}) async {
  final dir = await Directory.systemTemp.createTemp('crypto_fixture_');
  final file = File('${dir.path}/sample.bin');
  await file.writeAsBytes(fixtureBytes(size));
  return file;
}
